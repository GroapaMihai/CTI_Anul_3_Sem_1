<!DOCTYPE html>
<!-- saved from url=(0042)http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08 -->
<html lang="en" dir="ltr" class="js desktop"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>Laboratorul 8 - Recapitulare si completari [CN Wiki]</title>
    <script>(function(H){H.className=H.className.replace(/\bno-js\b/,'js')})(document.documentElement)</script>
    <meta name="generator" content="DokuWiki">
<meta name="robots" content="index,follow">
<meta name="date" content="2015-12-03T16:07:22+0200">
<meta name="keywords" content="lab,cn2,lab08">
<link rel="search" type="application/opensearchdescription+xml" href="http://elf.cs.pub.ro/cn/wiki/lib/exe/opensearch.php" title="CN Wiki">
<link rel="start" href="http://elf.cs.pub.ro/cn/wiki/">
<link rel="contents" href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08?do=index" title="Sitemap">
<link rel="alternate" type="application/rss+xml" title="Recent changes" href="http://elf.cs.pub.ro/cn/wiki/feed.php">
<link rel="alternate" type="application/rss+xml" title="Current namespace" href="http://elf.cs.pub.ro/cn/wiki/feed.php?mode=list&amp;ns=lab:cn2">
<link rel="alternate" type="text/html" title="Plain HTML" href="http://elf.cs.pub.ro/cn/wiki/_export/xhtml/lab/cn2/lab08">
<link rel="canonical" href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08">
<link rel="stylesheet" type="text/css" href="./Laboratorul 8 - Recapitulare si completari [CN Wiki]_files/css.php">
<script type="text/javascript">/*<![CDATA[*/var NS='lab:cn2';var JSINFO = {"id":"lab:cn2:lab08","namespace":"lab:cn2","isadmin":0,"isauth":0};
/*!]]>*/</script><style type="text/css"></style>
<script type="text/javascript" charset="utf-8" src="./Laboratorul 8 - Recapitulare si completari [CN Wiki]_files/js.php"></script>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="shortcut icon" href="http://elf.cs.pub.ro/cn/wiki/lib/tpl/dokuwiki/images/favicon.ico">
<link rel="apple-touch-icon" href="http://elf.cs.pub.ro/cn/wiki/lib/tpl/dokuwiki/images/apple-touch-icon.png">
    </head>

<body>
    <!--[if lte IE 7 ]><div id="IE7"><![endif]--><!--[if IE 8 ]><div id="IE8"><![endif]-->
    <div id="dokuwiki__site"><div id="dokuwiki__top" class="site dokuwiki mode_show tpl_dokuwiki    
	showSidebar 
	hasSidebar">

        
<!-- ********** HEADER ********** -->
<div id="dokuwiki__header"><div class="pad group">

    
    <div class="headings group">
        <ul class="a11y skip">
            <li><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#dokuwiki__content">skip to content</a></li>
        </ul>

        <h1><a href="http://elf.cs.pub.ro/cn/wiki/home" accesskey="h" title="Home"><img src="./Laboratorul 8 - Recapitulare si completari [CN Wiki]_files/logo.png" width="1242" height="407" alt=""></a></h1>
            </div>

    <div class="tools group">
        <!-- USER TOOLS -->
                    <div id="dokuwiki__usertools">
                <h3 class="a11y">User Tools</h3>
                <ul>
                    <li><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08?do=login&amp;sectok=a0d82294bf60552297e67b1fca60d14b" class="action login" rel="nofollow" title="Login">Login</a></li>                </ul>
            </div>
        
        <!-- SITE TOOLS -->
        <div id="dokuwiki__sitetools">
            <h3 class="a11y">Site Tools</h3>
            <form action="http://elf.cs.pub.ro/cn/wiki/home" accept-charset="utf-8" class="search" id="dw__search" method="get" role="search"><div class="no"><input type="hidden" name="do" value="search"><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]"><input type="submit" value="Search" class="button" title="Search"><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>            <div class="mobileTools">
                <form action="http://elf.cs.pub.ro/cn/wiki/doku.php" method="get" accept-charset="utf-8"><div class="no"><input type="hidden" name="id" value="lab:cn2:lab08"><select name="do" class="edit quickselect" title="Tools"><option value="">Tools</option><optgroup label="Page Tools"><option value="revisions">Old revisions</option><option value="backlink">Backlinks</option></optgroup><optgroup label="Site Tools"><option value="media">Media Manager</option><option value="index">Sitemap</option></optgroup><optgroup label="User Tools"><option value="login">Login</option></optgroup></select><input type="submit" value="&gt;" style="display: none;"></div></form>            </div>
            <ul>
                <li><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08?do=media&amp;ns=lab%3Acn2" class="action media" rel="nofollow" title="Media Manager">Media Manager</a></li><li><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08?do=index" class="action index" accesskey="x" rel="nofollow" title="Sitemap [X]">Sitemap</a></li>            </ul>
        </div>

    </div>

    
    <hr class="a11y">
</div></div><!-- /header -->

        <div class="wrapper group">

                            <!-- ********** ASIDE ********** -->
		<div id="dokuwiki__aside"><div class="pad include group">
                    <h3 class="toggle open" style="cursor: pointer; display: none;"><strong><span>−</span></strong>Sidebar</h3>
                    <div class="content" style="">
                                                                        
<p aria-expanded="true" style="">

</p><ul id="navbar" aria-expanded="true" style="">

<li>
<a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#">Laboratoare CN1</a>

<p></p>

<div><div id="nojs_indexmenu_15176734456d54cdeab3d0" data-jsajax="" class="indexmenu_nojs">

<ul class="idx" role="tree">
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn1/lab00" class="wikilink1" title="lab:cn1:lab00">Laboratorul 0 - Introducere in logica digitala. Falstad</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn1/lab01" class="wikilink1" title="lab:cn1:lab01">Laboratorul 1 - Introducere in Verilog</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn1/lab02_nou" class="wikilink1" title="lab:cn1:lab02_nou">Laboratorul 2 - Tipuri de descriere a modulelor in Verilog</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn1/lab03" class="wikilink1" title="lab:cn1:lab03">Laboratorul 3 - FPGA - laborator introductiv</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn1/lab04" class="wikilink1" title="lab:cn1:lab04">Laboratorul 4 - Automate cu stări simple</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn1/lab05" class="wikilink1" title="lab:cn1:lab05">Laboratorul 5 - FSM 2: afisajul cu 7 segmente</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn1/lab06" class="wikilink1" title="lab:cn1:lab06">Laboratorul 6 - FSM 3: UART</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn1/lab07" class="wikilink1" title="lab:cn1:lab07">Laboratorul 7 - Sumatoare</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn1/lab08" class="wikilink1" title="lab:cn1:lab08">Laboratorul 8 - Sumatorul Carry-Lookahead</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn1/lab09" class="wikilink1" title="lab:cn1:lab09">Laboratorul 9 - Unitatea aritmetică logică</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn1/lab10" class="wikilink1" title="lab:cn1:lab10">Laboratorul 10 - Tetris</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn1/labr" class="wikilink1" title="lab:cn1:labr">Laborator de recapitulare - Putting it all together: A simple processor</a></div></li>
</ul>
</div></div>

<p>

</p></li>


<li>
<a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#">Laboratoare CN2</a>

<p></p>

<div><div id="nojs_indexmenu_64635894056d54cdf01d37" data-jsajax="" class="indexmenu_nojs">

<ul class="idx" role="tree">
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab00" class="wikilink1" title="lab:cn2:lab00">Laboratorul 0 - Recapitulare</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab01" class="wikilink1" title="lab:cn2:lab01">Laboratorul 1 - Memorii</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab02" class="wikilink1" title="lab:cn2:lab02">Laboratorul 2 - Instruction Set Architecture 1</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab03" class="wikilink1" title="lab:cn2:lab03">Laboratorul 3 - Instruction Set Architecture 2</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab04" class="wikilink1" title="lab:cn2:lab04">Laboratorul 4 - Instruction Set Architecture 3</a></div></li>
<li class="level1" role="treeitem"><div class="li"><span class="curid"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab05" class="wikilink1" title="lab:cn2:lab05">Laboratorul 5 - Instruction Set Architecture 4</a></span></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab06" class="wikilink1" title="lab:cn2:lab06">Laboratorul 6 - GPIO 1: Output</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab07" class="wikilink1" title="lab:cn2:lab07">Laboratorul 7 - GPIO 2: Input</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08" class="wikilink1" title="lab:cn2:lab08">Laboratorul 8 - Recapitulare si completari</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab09" class="wikilink1" title="lab:cn2:lab09">Laboratorul 9 - Timer/Counter</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab10" class="wikilink1" title="lab:cn2:lab10">Laboratorul 10 - Intreruperi</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab11" class="wikilink1" title="lab:cn2:lab11">Laboratorul 11 - Recapitulare</a></div></li>
</ul>
</div></div>

<p>

</p></li>



<li>
<a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#">Tutoriale</a>

<p></p>

<div><div id="nojs_indexmenu_78829373456d54cdf865e4" data-jsajax="" class="indexmenu_nojs">

<ul class="idx" role="tree">
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/tutoriale/constraints-ise" class="wikilink1" title="tutoriale:constraints-ise">Asignarea pinilor de IO în Xilinx ISE</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/tutoriale/debug-ise" class="wikilink1" title="tutoriale:debug-ise">Debugging folosind Xilinx ISE</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/tutoriale/install-ise" class="wikilink1" title="tutoriale:install-ise">Instalarea Xilinx ISE WebPACK</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/tutoriale/programare-ise" class="wikilink1" title="tutoriale:programare-ise">Programarea FPGA-ului folosind Xilinx ISE</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/tutoriale/proiect-ise" class="wikilink1" title="tutoriale:proiect-ise">Crearea unui proiect în Xilinx ISE</a></div></li>
<li class="level1" role="treeitem"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/tutoriale/simulare-ise" class="wikilink1" title="tutoriale:simulare-ise">Simularea unui modul în Xilinx ISE</a></div></li>
</ul>
</div></div>

<p>

</p></li>


<li>
<a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#">Resurse</a>
<ul>
<li><a class="media mediafile mf_pdf" href="http://www.ece.uvic.ca/~fayez/courses/ceng465/vlogref.pdf"> Verilog Cheatsheet</a></li>
<li><a class="media mediafile mf_pdf" href="http://verilog.renerta.com/"> Verilog Language Reference</a></li>
<li><a class="media mediafile mf_pdf" href="http://www.digilentinc.com/Data/Products/NEXYS/Nexys_rm.pdf"> Digilent Nexys Board Manual</a></li>
</ul>
</li>

</ul>

<p aria-expanded="true" style=""></p>
                                            </div>
		</div></div><!-- /aside -->
            
	    <!-- BREADCRUMBS -->
	    		<div class="breadcrumbs">
		    			<div class="youarehere"><span class="bchead">You are here: </span><span class="home"><bdi><a href="http://elf.cs.pub.ro/cn/wiki/home" class="wikilink1" title="home">Calculatoare Numerice</a></bdi></span> » <bdi><a href="http://elf.cs.pub.ro/cn/wiki/lab/home" class="wikilink2" title="lab:home" rel="nofollow">lab</a></bdi> » <bdi><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/home" class="wikilink2" title="lab:cn2:home" rel="nofollow">cn2</a></bdi> » <bdi><span class="curid"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08" class="wikilink1" title="lab:cn2:lab08">Laboratorul 8 - Recapitulare si completari</a></span></bdi></div>
		    		    		</div>
	    
            <!-- ********** CONTENT ********** -->
            <div id="dokuwiki__content"><div class="pad group">

                <div class="page group" style="min-height: 37px;">
                                                            <!-- wikipage start -->
                    <!-- TOC START -->
<div id="dw__toc">
<h3 class="toggle open" style="cursor: pointer;"><strong><span>−</span></strong>Table of Contents</h3>
<div>

<ul class="toc" aria-expanded="true" style="">
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#timing-ul-instructiunilor">1. Timing-ul instructiunilor</a></div></li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#prescaler-si-surse-de-ceas">2. Prescaler si surse de ceas</a></div></li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#codul-morse">3. Codul Morse</a></div></li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#cerinte">4. Cerinte</a></div></li>
<li class="level1"><div class="li"><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#linkuri-utile">5. Linkuri utile</a></div></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 class="sectionedit1" id="laboratorul-8-recapitulare-si-completari">Laboratorul 8 - Recapitulare si completari</h1>
<div class="level1">
<ul>
<li class="level1"><div class="li"> Responsabil: <a href="mailto:olteanv@gmail.com" class="mail" title="olteanv@gmail.com">Vladimir Oltean</a></div>
</li>
<li class="level0"><div class="li"> Data publicării: 03.12.2014</div>
</li>
<li class="level0"><div class="li"> Data ultimei modificări: 03.12.2015</div>
</li>
</ul>

</div>

<h2 class="sectionedit2" id="timing-ul-instructiunilor">1. Timing-ul instructiunilor</h2>
<div class="level2">

<p>
Conceptul de timing se refera la duratele instructiunilor, masurate in cicli de ceas, impreuna cu frecventa de operare. Asa cum ne amintim din primele laboratoare, procesorul pe care l-am implementat pana acum este unul simplu, fara pipeline, in 5 stagii: <code>instruction fetch</code>, <code>instruction decode</code>, <code>execute</code>, <code>memory access</code> si <code>register writeback</code>. Fiindca fiecare etapa de instructiune se executa intr-un ciclu separat de ceas, putem deduce ca o instructiune AVR, pe procesorul nostru, dureaza 5 cicli de ceas.<br></p><p></p><div class="noteimportant">
<a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline" class="urlextern" title="http://en.wikipedia.org/wiki/Classic_RISC_pipeline" rel="nofollow">Design-urile clasice RISC</a>, desi au aceleasi etape de executie, pretind ca instructiunile se executa intr-un singur ciclu de ceas, spre deosebire de procesorul nostru, unde acestea se executa in 5. Motivul pentru aceasta discrepanta este fix <strong>pipeline</strong>-ul, absent in procesorul nostru: presupunand ca pipeline-ul este plin, atunci la fiecare moment de timp, in procesor vor fi intotdeauna 5 instructiuni in-flight, cate una in fiecare stagiu al executiei. Presupunand ca totul functioneaza corespunzator (nu avem hazarduri), atunci la fiecare ciclu de ceas, procesorul va termina de executat o instructiune, aflata intr-un stagiu terminal (<code>register writeback</code>), iar celelalte se vor shifta in urmatorul stagiu logic.<br>Cheia intelegerii aici este aceea ca cifra de 1 CPI pleaca de la o serie de presupuneri:
<p></p>
<ul>
<li class="level1"><div class="li"> pipeline-ul este mereu plin</div>
</li>
<li class="level1"><div class="li"> pipeline-ul contine instructiuni cu timing <strong>uniform</strong> (mai multe despre ele in continuare)</div>
</li>
</ul>

<p>

</p></div><p></p>
<p></p>

<p>
Instructiunile cu timing uniform sunt acelea care trec mereu prin aceeasi succesiune de etape de instructiune descrise mai sus. Exceptie de la acest grup de instructiuni fac:
</p>
<ul>
<li class="level1"><div class="li"> instructiunile de <strong>branch</strong> (salturi conditionate): procesorul face implicit presupunerea ca saltul nu va fi luat, deci instructiunile ce se vor executa vor fi cele din continuare (i + 1, i + 2, etc). Invalidarea pipeline-ului se face on-demand, daca presupunerea a fost gresita, asadar rezulta un timing diferit pentru acest tip de instructiuni, in functie de datele pe care le primesc la intrare (pentru branch taken rezulta un numar de cicli, pentru branch not taken alt numar de cicli).</div>
</li>
<li class="level1"><div class="li"> instructiunile pe <strong>32 de biti</strong>: procesorul nostru este unul cu instructiuni pe 16 biti, si magistrala de acces la memoria de instructiuni pe 16 biti. Totusi, unele instructiuni AVR (spre exemplu, o varianta a instructiunilor <code>lds</code> si <code>sts</code>), in incercarea de a cuprinde mai multa informatie in ele (cum ar fi o valoare imediata mai mare) sunt pe 32 de biti. In situatia in care avem unele instructiuni pe 16 si altele pe 32 de biti, singura solutie este sa citim chunk-uri de cate 16 biti o data, si daca depistam ca chunk-ul curent face parte dintr-o instructiune pe 32 de biti, pur si simplu continuam cu citirea celuilalt chunk. Acest tip de instructiuni se abate de la timing-ul uniform fiindca trece de doua ori, consecutiv, prin etapa de <code>instruction fetch</code></div>
</li>
<li class="level1"><div class="li"> <strong>stiva</strong>, spre deosebire de x86, unde este accesata numai pe 16 biti, la AVR poate fi accesata si pe 16, si pe 8 biti, instructiunile <code>push</code> si <code>pop</code> fiind cele care salveaza o valoare de 8 biti (cat un registru), iar <code>call</code> si <code>ret</code> fiind cele care salveaza o valoare pe mai multi biti, si anume <code>program counter</code>-ul (in mod cert mai mult de 8, in implementarea noastra 10, deci rotunjit la 16 biti). Aceste instructiuni au timing neuniform fiindca magistrala de acces la memorie este pe 8 biti, deci necesita doua treceri prin starea de <code>memory access</code>.</div>
</li>
</ul>

<p>
Unul din motivele puternice pentru a scrie un program in assembly este acela de a putea controla (oarecum) fin timing-ul instructiunilor (daca am fi scris codul in C, nu am fi avut control la fel de usor asupra instructiunilor generate de compilator).
</p>

<p>
Modalitatea prin care se calculeaza durata unei instructiuni assembly se face prin regula de trei simpla, pornind de la numarul de cicli in care se executa si de la frecventa de operare a procesorului. In datasheet-ul ATtiny20, Atmel pretinde “Up to 12 MIPS throughput at 12MHz”, ceea ce este echivalent cu 1 CPI (presupunand numai instructiuni cu timing uniform) la o frecventa de operare maxima de 12MHz.<br>Astfel, o frecventa de 12MHz inseamna ca intr-o secunda sunt 12 milioane de cicli de ceas, de unde rezulta ca un ciclu dureaza 1s / 12 milioane = 83.33 nanosecunde. Pentru procesoarele Atmel, care sunt in pipeline, aceasta cifra este egala si cu durata medie a unei instructiuni. Pentru procesorul nostru, care nu este in pipeline, trebuie sa mai inmultim cifra cu 5, si obtinem ca, la 12MHz, procesorul nostru ar fi capabil sa execute o instructiune AVR in 416.66 nanosecunde.
</p>

<p>
Pe de alta parte, nimic din design-ul Atmel nu ne obliga sa limitam frecventa de operare a microcontroller-ului nostru la doar 12MHz. Atunci cand sintetizam procesorul in Xilinx ISE, XST ne transmite urmatorul mesaj in consola:
</p>
<pre class="code"> Minimum period: 10.993ns (Maximum Frequency: 90.969MHz)
 Minimum input arrival time before clock: 1.145ns
 Maximum output required time after clock: 3.357ns
 Maximum combinational path delay: No path found</pre>

<p>
Aceasta cifra de 90MHz este dedusa in urma analizei timpilor de setup si de hold pentru bistabile, a delay-urilor combinationale, si a incarcarii (loading) retelei de distributie de ceas. Orice circuit digital are un fan-out<sup><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#fn__1" id="fnt__1" class="fn_top">1)</a></sup> finit, ceea ce inseamna ca, intr-o schema logica cu multe circuite, acestea nu pot fi legate toate la acelasi semnal de ceas, fiindca sarcina capacitiva pe care acestea o reprezinta ar incetini prea mult tranzitionarea ceasului din 0 in 1 si invers. Din acest motiv, mai multe <strong>clock buffers</strong> sunt folosite, ele fiind organizate sub forma unui arbore. Noua problema care apare, insa, este aceea ca buffer-ele mai adanci din arbore vor primi un semnal de ceas putin mai intarziat (<strong>clock skew</strong>), asa ca frecventa maxima, globala, a ceasului va trebui incetinita si ea, pentru a masca toate aceste diferente de timing.<br>Ideea, pe scurt, este aceea ca frecventa maxima la care poate opera un circuit logic scade, in principiu, cu complexitatea lui, insa mai sunt si alte considerente care intra in discutie pentru alegerea valorii “normale” a frecventei, cum ar fi consumul si rezistenta la zgomot si interferente.
</p>

</div>

<h2 class="sectionedit3" id="prescaler-si-surse-de-ceas">2. Prescaler si surse de ceas</h2>
<div class="level2">

<p>
Pana acum am vorbit despre semnalul de ceas, fara a mentiona cum poate fi acesta produs. Cea mai comuna metoda de a obtine un semnal de ceas este de la un <strong>oscilator</strong>: un dispozitiv electronic care genereaza un semnal (patrat sau sinusoidal) periodic cu o anumita frecventa. Pentru a produce acea frecventa, este nevoie de un <strong>rezonator</strong>: un alt dispozitiv, care are inductanta egala cu capacitatea, deci care nu se va stabiliza niciodata. Exemplu de astfel de dispozitive sunt <a href="http://en.wikipedia.org/wiki/Crystal_oscillator" class="urlextern" title="http://en.wikipedia.org/wiki/Crystal_oscillator" rel="nofollow">cristalele de quartz</a>, bazate pe efect piezoelectric, un <a href="http://en.wikipedia.org/wiki/RC_oscillator" class="urlextern" title="http://en.wikipedia.org/wiki/RC_oscillator" rel="nofollow">oscilator RC</a> (analogice, produc un semnal de ceas sinusoidal) sau un <a href="http://en.wikipedia.org/wiki/555_timer_IC" class="urlextern" title="http://en.wikipedia.org/wiki/555_timer_IC" rel="nofollow">multivibrator</a> (digital, produce un semnal de ceas dreptunghiular).<br>Una din principalele probleme cu un semnal de ceas neprelucrat este <a href="http://en.wikipedia.org/wiki/Jitter" class="urlextern" title="http://en.wikipedia.org/wiki/Jitter" rel="nofollow">clock jitter</a>-ul, un fenomen prin care acesta isi pierde periodicitatea. Pentru a ameliora aceasta problema, semnalul de ceas este trecut printr-un dispozitiv numit PLL (<strong>phase-locked loop</strong>), care este un sistem de reglare automata cu o bucla de reactie pentru faza semnalului de ceas. Ceea ce controleaza aceasta bucla de reactie este un alt semnal de ceas, ce va avea o faza stabilizata (un jitter mic) si o frecventa egala sau multiplu de frecventa semnalului de ceas de la intrare.<br>Daca PLL-ul are un factor de multiplicare de 4x, atunci o frecventa de intrare ce vine de la oscilator (ce are, sa spunem, 4MHz) va avea 16MHz la iesirea din PLL. In acest fel se pot obtine frecvente multiplicate ale unui semnal, fara a-i multiplica si eroarea (jitter-ul).<br>Foarte multe microcontrollere includ un dispozitiv PLL in interiorul lor. Un alt exemplu il constituie procesoarele x86, care ruleaza pe baza semnalului de ceas al FSB-ului, insa la o frecventa multiplicata a acestuia (daca FSB opereaza la 100MHz, si CPU-ul are un clock multiplier de 20, atunci va opera la 2000MHz). Schimband frecventa FSB-ului, se schimba automat si frecventa CPU-ului datorita acestui sistem PLL.
</p>

<p>
De asemenea, pe langa multiplicarea frecventei unui semnal de ceas, poate in unele situatii dorim sa o reducem. Aceasta operatie se cheama <strong>prescaling</strong> (exista si postscaling, care face cam acelasi lucru), si realizeaza o reducere a frecventei ceasului cu o putere a lui 2.<br>Prescaler-ul este un modul digital aflat in interiorul procesorului, care poate fi configurat pe mai multi factori de reducere (1:1 inseamna frecventa lui clkOut = frecventa lui clkIn; 1:2 inseamna frecventa lui clkOut = (frecventa lui clkIn)/2; 1:4, 1:8, 1:32, etc).<br>Metoda folosita, in general, pentru implementarea unui prescaler este un <strong>counter</strong> (numarator). Sa presupunem un numarator pe 3 biti si sa vedem cum alterneaza bitii lui:
</p>
<div class="table sectionedit4"><table class="inline">
	<tbody><tr class="row0">
		<th class="col0 centeralign">  Cycle  </th><th class="col1 centeralign">  Value  </th>
	</tr>
	<tr class="row1">
		<td class="col0 centeralign">  0  </td><td class="col1 centeralign">  111  </td>
	</tr>
	<tr class="row2">
		<td class="col0 centeralign">  1  </td><td class="col1 centeralign">  110  </td>
	</tr>
	<tr class="row3">
		<td class="col0 centeralign">  2  </td><td class="col1 centeralign">  101  </td>
	</tr>
	<tr class="row4">
		<td class="col0 centeralign">  3  </td><td class="col1 centeralign">  100  </td>
	</tr>
	<tr class="row5">
		<td class="col0 centeralign">  4  </td><td class="col1 centeralign">  011  </td>
	</tr>
	<tr class="row6">
		<td class="col0 centeralign">  5  </td><td class="col1 centeralign">  010  </td>
	</tr>
	<tr class="row7">
		<td class="col0 centeralign">  6  </td><td class="col1 centeralign">  001  </td>
	</tr>
	<tr class="row8">
		<td class="col0 centeralign">  7  </td><td class="col1 centeralign">  000  </td>
	</tr>
</tbody></table></div>
<pre class="code">cycle         0       1       2       3       4       5       6       7
              ___     ___     ___     ___     ___     ___     ___     ___     __
clkIn      __/   \___/   \___/   \___/   \___/   \___/   \___/   \___/   \___/
              _______         _______         _______         _______         __
value[0]   __/       \_______/       \_______/       \_______/       \_______/
              _______________                 _______________         __________
value[1]   __/               \_______________/               \_______/       
              _______________________________                                 __
value[2]   __/                               \_______________________________/</pre>

<p>
Daca ne uitam pe verticala la bitii lui <code>value</code> pentru fiecare valoare a lui <code>cycle</code>, vom recunoaste valorile din tabel. Insa daca ne uitam la perioada semnalelor, observam ca este mai mare cu cat avansam mai mult in indexul bitului din numarator (bitul 0 se schimba la jumatate din frecventa ceasului, bitul 1 se schimba la jumatate din frecventa bitului 0, etc). Daca am folosi, in loc de <code>clkIn</code>, drept clock pe unul din bitii numaratorului, am obtine efectiv un semnal de ceas divizat cu o putere a lui 2.<br>Ceea ce dorim sa obtinem este un mod de a controla si a regla exact cat dureaza o instructiune assembly, pentru a putea face lucruri in functie de aceasta valoare (spre exemplu, delay-uri de un numar precizat de milisecunde).
</p>

</div>

<h2 class="sectionedit5" id="codul-morse">3. Codul Morse</h2>
<div class="level2">

<p>
Este o metoda prin care setul de caractere <abbr title="American Standard Code for Information Interchange">ASCII</abbr> poate fi convertit intr-o serie de <a href="http://en.wikipedia.org/wiki/American_Morse_code" class="urlextern" title="http://en.wikipedia.org/wiki/American_Morse_code" rel="nofollow">semnale lungi sau scurte</a>, separate de pauze mai mari unele de altele.<br>Pentru situatiile in care codul pe care il punem pe microcontroller nu functioneaza asa cum ne dorim, avem mai multe solutii:
</p>
<ul>
<li class="level1"><div class="li"> folosim un <strong>in-circuit debugger</strong>, un dispozitiv electronic ce ne poate fi de un real folos, fiind bazat pe breakpoint-uri si intreruperi de trace hardware, si fiind capabil sa faca dump la valorile registrelor si ale memoriei</div>
</li>
<li class="level1"><div class="li"> folosim <strong>printf debugging</strong>, o metoda prin care incercam sa comunicam utilizatorului valoarea unei variabile interne, sau faptul ca am ajuns la un anumit punct in cod. In mod evident, modalitatile de comunicare pe un microcontroller sunt mai restranse decat printf-ul pe un PC, insa printre metode se numara:</div>
<ul>
<li class="level3"><div class="li"> studierea cu multimetrul a tensiunilor electrice de pe pinii de GPIO</div>
</li>
<li class="level3"><div class="li"> “redirectarea stdout-ului” la o linie de transmisie seriala, pe care o putem lega apoi la un convertor USB-serial si apoi la PC</div>
</li>
<li class="level3"><div class="li"> <strong>LED-ul de debug</strong>: atunci cand pare ca nu merge nimic, este greu de stabilit o legatura seriala pe care sa facem debug, si atunci un simplu LED este o interfata de debugging mult mai potrivita.</div>
</li>
</ul>
</li>
</ul>

<p>
Pe un LED se pot transmite atat informatii simple, binare (da/nu) de tipul “a ajuns executia in acest punct?”, “este aceasta variabila zero?” etc, sau informatii mai complexe, codificate, spre exemplu, in cod Morse. Avantajul acestei metode fata de o codificare NRZ, spre exemplu, care este folosita in transmisia RS232, ar fi faptul ca putem folosi aplicatii de Android pentru a decodifica mesajul pe care microcontroller-ul incearca sa ni-l transmita.
</p>

</div>

<h2 class="sectionedit6" id="cerinte">4. Cerinte</h2>
<div class="level2">

<p>
<strong>1. (4p)</strong> In scheletul de cod, portul A a fost mapat la LED-urile 7-0 de pe placa Digilent Nexys. Scrieti un program in assembly de AVR care functioneaza ca un numarator afisat pe LED-uri: valoarea afisata pe cele 8 LED-uri (care initial e 0) se incrementeaza folosind un counter (adica un registru pe care il tot incrementati). Va trebui sa folositi o functie de delay intre incrementari, pentru a putea vizualiza valoarea acestui counter pe LED-uri (altfel acel counter ar numara prea repede pentru ca voi sa apucati sa vedeti LED-urile aprinse).
</p>

<p>
Vedeti <a href="https://elf.cs.pub.ro/cn/wiki/aux/cn2/aux2" class="urlextern" title="https://elf.cs.pub.ro/cn/wiki/aux/cn2/aux2" rel="nofollow"> AVR Assembler crash course</a> pentru detalii despre cum sa programati in AVR Assembler si despre utilitarul avrasm (vezi punctul 2).
</p>

<p>
Un exemplu de cod este aici:<br>
</p>
<dl class="code">
<dt><a href="http://elf.cs.pub.ro/cn/wiki/_export/code/lab/cn2/lab08?codeblock=0" title="Download Snippet" class="mediafile mf_asm">counter.asm</a></dt>
<dd><pre class="code asm">        <span class="co1">; definitii</span>
        SPH         <span class="kw5">equ</span> <span class="nu0">0x3E</span>
        <span class="kw4">SPL</span>         <span class="kw5">equ</span> <span class="nu0">0x3D</span>
        PORTA       <span class="kw5">equ</span> <span class="nu0">0x02</span>
        DDRA        <span class="kw5">equ</span> <span class="nu0">0x01</span>
        RAMEND      <span class="kw5">equ</span> <span class="nu0">0xBF</span>
&nbsp;
        rjmp        _start
&nbsp;
        <span class="co1">; functia delay primeste in R17 valoarea pana la care</span>
        <span class="co1">; trebuie sa itereze</span>
_delay<span class="sy1">:</span> <span class="kw1">dec</span>         R17
        brne        _delay          <span class="co1">; flagul de zero este setat direct de "dec"</span>
        <span class="kw1">ret</span>
&nbsp;
_start<span class="sy1">:</span> ldi         R16<span class="sy1">,</span> <span class="nu0">0</span>
        <span class="kw1">out</span>         SPH<span class="sy1">,</span> R16
        ldi         R16<span class="sy1">,</span> RAMEND
        <span class="kw1">out</span>         <span class="kw4">SPL</span><span class="sy1">,</span> R16
        ldi         R16<span class="sy1">,</span> <span class="nu0">0xFF</span>
        <span class="kw1">out</span>         DDRA<span class="sy1">,</span> R16
&nbsp;
inceput<span class="sy1">:</span>
        ldi R16<span class="sy1">,</span> <span class="nu0">0</span>
repeta<span class="sy1">:</span>
        <span class="co1">; TODO: puneti aici valoarea lui R16 in PORTA (folositi instr. out)</span>
&nbsp;
        <span class="co1">; TODO: incrementati pe R16</span>
&nbsp;
        <span class="co1">; TODO: asteptati ceva vreme (folositi functia _delay si instr. rcall)</span>
        <span class="co1">; Atentie: inainte de a apela functia delay trebuie sa setati valoarea lui R17 pentru  specifica cat timp sa astepte</span>
&nbsp;
        <span class="co1">; ne intoarcem de la repeta</span>
        rjmp repeta</pre>
</dd></dl>

<p>
<strong>2. (4p)</strong> Asamblati codul pe care l-ati scris la punctul anterior folosind <br><a href="http://elf.cs.pub.ro/cn/wiki/_media/aux/cn2/avrasm.zip" class="media mediafile mf_zip" title="aux:cn2:avrasm.zip (55.4 KB)">utilitarul avrasm</a> si verificati faptul ca functioneaza corect programandu-l pe placuta Digilent Nexys (copiati codul din <code>a.out</code> in <code>rom.v</code>).
</p>

<p>
<strong>3. (2p)</strong> Scrieti un program care foloseste LED-ul conectat la PORTA[0] pentru a transmite, caracter cu caracter, un string null-terminated din memoria microcontroller-ului. Transmisia se va face folosind codul Morse. Va trebui sa aveti doua functii: <em>dash</em>, care tine LED-ul aprins timp de 500ms, si <em>dot</em>, care il tine aprins timp de 200ms. Spatiile dintre doua semnale consecutive trebuie sa fie de aproximativ 200ms, iar spatiile dintre doua litere consecutive de aproximativ o secunda. Este de datoria voastra sa ganditi modul cum obtineti valorile pentru aceste delay-uri, folosindu-va de oscilatorul reglabil de 25/50MHz de pe placa Digilent Nexys, de bitii de prescaler de pe switch-urile SW[4:0] si de codul pe care il scrieti.
</p>

<p>
Apoi, folosind aplicatia Android “Morse Talk” in modul “chat”, cititi cu ajutorul camerei de pe telefonul mobil ceea ce afiseaza LED-ul de pe placa cu FPGA. Transmiteti sirul de caractere “America”.
</p>



</div>

<h2 class="sectionedit7" id="linkuri-utile">5. Linkuri utile</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="http://www.atmel.com/Images/doc2551.pdf" class="urlextern" title="http://www.atmel.com/Images/doc2551.pdf" rel="nofollow">http://www.atmel.com/Images/doc2551.pdf</a></div>
</li>
<li class="level0"><div class="li"> <a href="http://elf.cs.pub.ro/cn/wiki/_media/lab/cn2/cn_schelet_lab8.zip" class="media mediafile mf_zip" title="lab:cn2:cn_schelet_lab8.zip (1.6 MB)">cn_schelet_lab8.zip</a></div>
</li>
<li class="level0"><div class="li"> <a href="https://elf.cs.pub.ro/cn/wiki/aux/cn2/aux2" class="urlextern" title="https://elf.cs.pub.ro/cn/wiki/aux/cn2/aux2" rel="nofollow"> AVRAsm</a></div>
</li>
<li class="level0"><div class="li"> <a href="https://elf.cs.pub.ro/cn/wiki/aux/cn2/aux1" class="urlextern" title="https://elf.cs.pub.ro/cn/wiki/aux/cn2/aux1" rel="nofollow"> Scheletul procesorului ATTinty20</a></div>
</li>
<li class="level0"><div class="li"> <a href="http://www.atmel.com/images/doc0856.pdf" class="urlextern" title="http://www.atmel.com/images/doc0856.pdf" rel="nofollow"> Set de instructiuni AVR</a></div>
</li>
</ul>

</div>
<div class="footnotes">
<div class="fn"><sup><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#fnt__1" id="fn__1" class="fn_bot">1)</a></sup> 
cantitatea de curent care poate fi trasa din output-ul lui pana ca tensiunea de iesire sa scada sub un nivel logic acceptabil</div>
</div>

                    <!-- wikipage stop -->
                                    </div>

                <div class="docInfo"><bdi>lab/cn2/lab08.txt</bdi> · Last modified: 03.12.2015 by <bdi>Tudor Vișan</bdi></div>

                            </div></div><!-- /content -->

            <hr class="a11y">

            <!-- PAGE ACTIONS -->
            <div id="dokuwiki__pagetools">
                <h3 class="a11y">Page Tools</h3>
                <div class="tools">
                    <ul>
                        <li><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08?do=revisions" class="action revs" accesskey="o" rel="nofollow" title="Old revisions [O]"><span>Old revisions</span></a></li><li><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08?do=backlink" class="action backlink" rel="nofollow" title="Backlinks"><span>Backlinks</span></a></li><li><a href="http://elf.cs.pub.ro/cn/wiki/lab/cn2/lab08#dokuwiki__top" class="action top" accesskey="t" rel="nofollow" title="Back to top [T]"><span>Back to top</span></a></li>                    </ul>
                </div>
            </div>
        </div><!-- /wrapper -->

        
<!-- ********** FOOTER ********** -->
<div id="dokuwiki__footer"><div class="pad">
    <div class="license">Except where otherwise noted, content on this wiki is licensed under the following license: <bdi><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="license" class="urlextern">CC Attribution-Noncommercial-Share Alike 3.0 Unported</a></bdi></div>
    <div class="buttons">
        <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="license"><img src="./Laboratorul 8 - Recapitulare si completari [CN Wiki]_files/cc-by-nc-sa.png" alt="CC Attribution-Noncommercial-Share Alike 3.0 Unported"></a>        <a href="http://www.dokuwiki.org/donate" title="Donate"><img src="./Laboratorul 8 - Recapitulare si completari [CN Wiki]_files/button-donate.gif" width="80" height="15" alt="Donate"></a>
        <a href="http://www.php.net/" title="Powered by PHP"><img src="./Laboratorul 8 - Recapitulare si completari [CN Wiki]_files/button-php.gif" width="80" height="15" alt="Powered by PHP"></a>
        <a href="http://validator.w3.org/check/referer" title="Valid HTML5"><img src="./Laboratorul 8 - Recapitulare si completari [CN Wiki]_files/button-html5.png" width="80" height="15" alt="Valid HTML5"></a>
        <a href="http://jigsaw.w3.org/css-validator/check/referer?profile=css3" title="Valid CSS"><img src="./Laboratorul 8 - Recapitulare si completari [CN Wiki]_files/button-css.png" width="80" height="15" alt="Valid CSS"></a>
        <a href="http://dokuwiki.org/" title="Driven by DokuWiki"><img src="./Laboratorul 8 - Recapitulare si completari [CN Wiki]_files/button-dw.png" width="80" height="15" alt="Driven by DokuWiki"></a>
    </div>
</div></div><!-- /footer -->

    </div></div><!-- /site -->

    <div class="no"><img src="./Laboratorul 8 - Recapitulare si completari [CN Wiki]_files/indexer.php" width="2" height="1" alt=""></div>
    <div id="screen__mode" class="no"></div>    <!--[if ( lte IE 7 | IE 8 ) ]></div><![endif]-->


</body></html>